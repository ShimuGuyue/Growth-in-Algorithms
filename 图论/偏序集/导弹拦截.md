# 题目链接

[P1020 [NOIP 1999 提高组] 导弹拦截 - 洛谷](https://www.luogu.com.cn/problem/P1020)

# 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

## 输入格式

一行，若干个正整数 $a_i(1 \leq a_i \leq 5 \times 10 ^ 4)$，中间由空格隔开。

正整数的个数不超过 $10 ^ 5$ 个。

## 输出格式

输出共两行。

第一行，一个数字表示这套系统最多能拦截多少导弹。

第二行，一个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

## 样例

| Input                          | OutPut  |
| ------------------------------ | ------- |
| 389 207 155 300 299 170 158 65 | 6<br/>2 |

# 解题思路

>   $dilworth$ 定理：对于任意偏序集，其最长链的长度与其反链划分的最小个数可以互相转换。

该定理在这道题目中的体现：最长不上升子序列的长度等价于可以将整个序列划分为若干个严格上升子序列的最小个数。

所以本体的两问都可以通过求最小序列划分个数来求解。

对于求严格上升子序列的最小划分个数，可以用**贪心**+**二分**的思想。

首先准备一个集合保存所有严格上升子序列的末尾值即最大值，然后依次处理每一个数 $x$：

+   若集合中存在若干个值小于 $x$，则选取这些值中最大的那个，将 $x$ 放在其对应的序列末尾；
+   否则，将 $x$ 作为一个新序列的第一个元素放入集合中。

最终求出**集合中数的个数即为序列最小划分个数**。

第二问求不上升子序列最小划分个数同理。

# 代码实现

```c++
void solve()
{
    vector<int> as;
    as.reserve(1e5);

    int a;
    while (cin >> a)
    {
        as += a;
    }

    // 根据处理每个数的过程，可以证明集合中数的大小具有单调性
    vector<int> ups;
    for (int h : as)
    {
        auto it = upper_bound(ups.begin(), ups.end(), h,
                              [](int a, int b)
                              {
                                  return a > b;
                              });
        if (it == ups.end())
            ups += h;
        else
            *it = h;
    }
    cout << ups.size() << endl;

    vector<int> down_equals;
    for (int h : as)
    {
        auto it = lower_bound(down_equals.begin(), down_equals.end(), h,
                              [](int a, int b)
                              {
                                  return a < b;
                              });
        if (it == down_equals.end())
            down_equals += h;
        else
            *it = h;
    }
    cout << down_equals.size() << endl;
}
```

