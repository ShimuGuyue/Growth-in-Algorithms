# 题目链接

[F-小红的排列构造_牛客周赛 Round 111](https://ac.nowcoder.com/acm/contest/117763/F)

# 题目描述

对于一个数组，小苯可以做任意次如下操作：

+   交换数组中的任意两个元素。

现在小红想要构造一个长为 $n$ 的排列 $a$，对所有的 $a_i$ 都满足 $a_i \neq i$，使得小苯将数组变为升序的最小操作数为 $k$。

请你帮帮小红。

## 输入格式

第一行输入两个整数 $n, k(2 \leq n \leq 2 \times 10 ^ 5, 1 \leq k \leq 2 \times 10 ^ 5)$。

## 输出格式

如果不存在符合条件的排列，请输出 $-1$，否则输出 $n$ 个整数，代表所构造的排列。

如果存在多个解决方案，您可以输出任意一个。

## 样例

| Input | OutPut  |
| ----- | ------- |
| 4 2   | 4 3 2 1 |

样例 1 说明：小苯可以进行如下的两次操作 $\{\underline{4}, 3, 2, \underline{1}\} \rightarrow \{\underline{1}, 3, 2,\underline{4}\}$，$\{1, \underline{3}, \underline{2}, 4\} \rightarrow \{1, \underline{2}, \underline{3}, 4\}$。可以证明，不存在比 $2$ 次更少的操作次数。

# 解题思路

> 对于每个置换环，将其复原所需的次数为元素个数减一。

将数组变为升序的结果只有一种情况，$\forall i, a_i = i$。

首先考虑无解的情况，最优操作下，每次操作至少使一个元素归位，且最后一次操作必定使两个元素归位，因此**操作次数至多为 $n - 1$**；最优排列情况下，每次操作至多使两个元素归位，因此**操作数至少为 $\lceil \frac{n}{2} \rceil$**。若题目所给 $k$ 值不在次区间内则无解。

可以将整个数组分成**左中右**三个部分 **(L, M, R)**，其中 $L$ 部分和 $R$ 部分长度相等 **$(len_{out} <= \lfloor \frac{n}{2} \rfloor)$**，对于这两个区域需保证每次操作都能使两个元素归位，即 $\forall i, j \in [1, len_{out}] \cup [n - len_{out} + 1, n], a_i = j, a_j = i$，**该部分归位的花费为 $len_{out}$**；对于 $M$ 部分 **$(len_{in} = n - len_{out} \times 2)$**，将内部元素在保证一次只能归位一个元素的前提下进行排列，**该部分的花费为 $len_{in} - 1$**。二者相加最终得到**总花费为 $n - len_{out} - 1$**。

在 $k$ 的约束条件下，$\forall k \in [\lceil \frac{n}{2} \rceil, n - 1]$，$len_{out}$ 总是有解。解出 $len_{out}$ 的长度之后，对三部分分别构造即可。

# 代码实现

```c++
void solve()
{
    int n, m;
    std::cin >> n >> m;

    if (m >= n)
    {
        std::cout << -1 << std::endl;
        return;
    }

    if (m < (n + 1) / 2)
    {
        std::cout << -1 << std::endl;
        return;
    }

    int dif = n - m - 1;
    for (int i = 0; i < dif; ++i)
    {
        std::cout << n - i << " ";
    }

    cout << m + 1 << " ";
    for (int i = dif + 1; i <= m; ++i)
    {
        std::cout << i << " ";.
    }

    for (int i = dif; i > 0; --i)
    {
        std::cout << i << " ";
    }
    std::cout << std::endl;
}
```

