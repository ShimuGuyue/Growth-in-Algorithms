# 题目链接

[E-小芳的排列构造_牛客周赛 Round 111](https://ac.nowcoder.com/acm/contest/117763/E)

# 题目描述

在此题中，我们认为数组以从左到右的顺序排列。

对于一个数组 $a$，小芳定义两个函数 $L(a)$ 与 $R(a)$ 为：

+   $L(a)$：数组中所有满足“大于其**左**侧所有数”的数之和。
+   $R(a)$：数组中所有满足“大于其**右**侧所有数”的数之和。

如，设一个数组 $b = \{2, 3, 4, 3, 5, 1\}$，则 $L(b) = 2 + 3 + 4 + 5 = 14$，$R(b) = 1 + 5 = 6$。

小芳希望小红构造一个长为 $n$ 的**排列** $c$，使得 $L(c) + R(c) = k$。请你帮帮小红。	

【名词解释】 

排列：长度为 $n$ 的排列是由 $1, 2, \dots, n$ 这 $n$ 个整数、按任意顺序组成的数组（每个整数均恰好出现一次）。例如，$\{2, 3, 1, 5, 4\}$ 是一个长度为 $5$ 的排列，而 $\{1, 2, 2\}$ 和 $\{1, 3, 4\}$ 都不是排列，因为前者存在重复元素，后者包含了超出范围的数。

## 输入格式

第一行输入两个整数 $n,k(1 \leq n \leq 2 \times 10 ^ 5, 1 \leq k \leq 10^{12})$。

## 输出格式

如果不存在这样的排列，请输出 $-1$，否则输出 $n$ 个整数，代表所构造的排列 $c$。

如果存在多个解决方案，您可以输出任意一个。

## 样例

| Input | OutPut  |
| ----- | ------- |
| 4 14  | 1 2 3 4 |
| 3 10  | -1      |

样例 1 说明：在此答案中，$L(c) = 1 + 2 + 3 + 4 = 10$，$R(c) = 4$，$L(c) + R(c) = 14$。

样例 2 说明：可以证明不存在符合条件的排列。

# 解题思路

对于任意排列，**最大的数**一定同时满足“大于其左侧所有的数”和“大于其右侧所有的数”，对排列总权值的**贡献值为 $2$**；**第二大的数**一定满足两种情况之一，因为其一侧有一个最大的数导致该方向贡献为 $0$，而另一侧没有比它更大的数导致该方向贡献为 $1$，**总贡献为 $1$**；对于**其他所有数**，其一侧一定有一个比他大的数导致该方向贡献为 $0$，在剩下的所有数中仍至少有一个比它大的数，因此根据数的位置，另一侧的贡献可能为 $1$ 或 $0$，**总贡献值为 $1$ 或 $0$**。

考虑无解的情况，排列的最大权值为 $\sum_{i=1}^{n} i + n = \frac{n \times (n + 1)}{2} + n$，最小权值为 $n \times 2 + (n - 1) = 3n - 1$。若题目所给 $k$ 值不在该区间内则无解。

对于有解的情况，先将最大的两个数 $A, B$ 放好作为后续放置其它数的基准。然后算出相较于最大权值，需要减少多少权值 **$(dif)$** 可以得到目标权值。然后根据 $dif$，从 $[1, n - 2]$ 的区间中选取和为 $dif$ 的一部分数放在 $A, B$ 之间，从总权值中减去对应的权值，然后将剩下的数放在 $A, B$ 外侧，得到构造结果。

# 代码实现

```c++
void solve()
{
    int64_t n, m;
    cin >> n >> m;

    if (n * (n + 1) / 2 + n < m)
    {
        cout << -1 << endl;
        return;
    }

    if (n * 2 + n - 1 > m)
    {
        cout << -1 << endl;
        return;
    }

    int64_t dif = n * (n + 1) / 2 + n - m;
    vector<bool> ignores(n + 1);
    int flag = n - 2;
    while (dif > 0)
    {
        if (dif >= flag)
        {
            dif -= flag;
            ignores[flag] = true;
        }
        --flag;
    }

    cout << n << " ";
    for (int i = 1; i < n; ++i)
    {
        if (ignores[i])
            cout << i << " ";
    }
    for (int i = n - 1; i >= 1; --i)
    {
        if (!ignores[i])
            cout << i << " ";
    }
    cout << endl;

}
```

