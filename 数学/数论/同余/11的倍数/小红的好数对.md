# 题目链接

[D-小红的好数对_牛客周赛 Round 111](https://ac.nowcoder.com/acm/contest/117763/D)

# 题目描述

小红定义一个数对 $(A, B)$ 是好的，当且仅当将 $B$ 拼接到 $A$ 之后，得到的新数是 $11$ 的倍数。

如 $(121, 11)$ 是一个好数对，因为 $12111$ 是 $11$ 的倍数。

小红拿到了一个长为 $n$ 的数组 $a$，他想知道，由数组中的任意两个不同元素组成的所有数对中，有多少是好的？

## 输入格式


第一行输入一个整数 $n( 2\leq n \leq 2 \times 10 ^ 5)$

第二行输入 $n$ 个整数 $a_i(1\leq a_i \leq 10 ^ 9)$。

## 输出格式

输出一个整数，代表好数对的数量。

## 样例

| Input                    | Output |
| ------------------------ | ------ |
| 6<br/>11 45 14 191 98 10 | 4      |
| 2<br/>1 1                | 2      |

样例 1 说明：四个好数对为 $(45, 98), (45, 10), (98, 45), (10, 45)$。

# 解题思路

> $11$ 的倍数的性质：奇数位数字之和与偶数位之和的差值是 $11$ 的倍数。

预处理每个数字的奇数位之和和偶数位之和的差值 **$(dif)$**。记录各个 $dif$ 的出现次数 **$count$**。

尝试将每个数作为数对$(A, B)$ 中的 $B$，根据 $B$ 的长度 **$(len)$** 及其 **$dif_B$**，决定 $A$ 的 **$(dif_A)$**：
	如果 $len$ 是偶数，$A$ 放入数对之后奇偶数位不变，$dif_A$ 不变，则 $dif_B+ dif_A \equiv 0 \pmod{11}$；
	如果 $len$ 是奇数，$A$ 放入数对之后奇偶数位互换，$dif_A$ 变为相反数，则 $dif_B - dif_A \equiv 0 \pmod{11}$。
	最后特判 $dif_A = dif_B$ 的情况，一个数不能同时为 $A$ 和 $B$。

对于每个 $B$，累加 $count_{dif_A}$ 得到答案。

# 代码实现

```c++
using std::int64_t;

void solve()
{
    int n;
    std::cin >> n;
    std::vector<int> as(n);
    std::cin >> as;

    std::vector<int> difs(n);

    std::array<int64_t, 11> counts{};

    for (int i = 0; i < n; ++i)
    {
        std::string s = std::to_string(as[i]);
        std::reverse(s.begin(), s.end());
        int sum_odd  = 0;
        int sum_even = 0;
        for (int j = 0; j < s.length(); ++j)
        {
            if (j & 1)
                sum_even += s[j] ^ '0';
            else
                sum_odd  += s[j] ^ '0';
        }
        int flag = ((sum_odd - sum_even) % 11 + 11) % 11;
        difs[i] = flag;
        ++counts[flag];
    }

    int64_t ans = 0;
    for (int i = 0; i < n; ++i)
    {
        int dif = difs[i];
        int len = to_string(as[i]).length();
        if (len & 1)
        {
            if (dif == 0)
            {
                int flag = 0;
                ans += counts[flag] - 1;
            }
            else
            {
                //* dif - flag = 0(mod 11)
                int flag = dif;
                ans += counts[flag] - 1;
            }
        }
        else
        {
            if (dif == 0)
            {
                int flag = 0;
                ans += counts[flag] - 1;
            }
            else
            {
                //* dif + flag = 0(mod 11)
                int flag = 11 - dif;
                ans += counts[flag];
            }
        }
    }
    std::cout << ans << std::endl;
}
```

