# 题目链接

[E-Beautiful Sequence_牛客周赛 Round 112](https://ac.nowcoder.com/acm/contest/118247/E)

# 题目描述

由于经常做不出 $\gcd$ 题，因此小苯不喜欢 $\gcd$，所以小苯认为：数组的 $\gcd$ **不存在**于数组中的话，则该数组是美丽的。

他现在有一个长度为 $n$ 的序列 $a$，请你帮他算一算，$a$ 中有多少个非空子序列（不要求连续）是美丽的数组吧。

【子序列】：子序列为从原数组中删除任意个（可以为零、可以为全部）元素得到的新数组。

【数组的 $\gcd$】：即数组中所有数字的最大公约数。（特别的，只有一个元素的话，则该数组 $\gcd$ 就等于这个元素的值。）

## 输入格式

每个测试文件均包含多组测试数据。第一行输入一个整数 $T(1 \leq T \leq 100)$ 代表数据组数，每组测试数据描述如下：

第一行一个正整数 $n(1 \leq n \leq 2 \times 10 ^ 5)$，表示序列 $a$ 的长度。

第二行 $n$ 个正整数 $a_i(1 \leq a_i \leq n)$，表示序列 $a$。

除此之外，保证单个测试文件的 $n$ 之和不超过 $2 \times 10 ^ 5$。

## 输出格式

对于每组测试数据：

在单独的一行输出一个整数，表示 "美丽的" 子序列个数。

（由于答案可能很大，因此输出其对 $998244353$ 取模后的值。）

## 样例

| Input                                   | OutPut   |
| --------------------------------------- | -------- |
| 2<br/>6<br/>1 2 3 4 5 6<br/>3<br/>2 2 2 | 22<br/>0 |

样例 1 说明：对于第二组测试数据，显然不存在这样的子序列，因此输出 $0$。

# 解题思路

>   对于任意若干个正整数的集合，集合的 $\gcd$ 一定不大于集合中的最小值。

由上述性质可得，集合的 $\gcd$ 存在两种情况：

+   $\gcd$ **小于**集合中的最小值，此时数组“美丽”；
+   $\gcd$ **等于**集合中的最小值，此时数组“不美丽”。（此时集合中的所有数都是最小数的倍数。）

在这两种情况中，数组“不美丽”的情况由于元素间的倍数关系，数量求解难度远小于数组“美丽”的情况。因此**正难则反**，用非空子序列的总个数减去“不美丽”子序列的个数即为所求答案，将问题转化为有多少个非空子序列满足**所有数都是最小数的倍数**。

判断个数时，可以依次以数组中每个数作为集合中的最小数，找到其所有倍数的个数。由于 $a_i \leq n \leq 2 \times 10 ^ 5$，因此枚举数据范围内每个数的倍数个数，时间复杂度为调和级数 $O(n \log n)$。

对于每个数 $x$ 作为最小数时，“不美丽”的子序列总个数为 **$x$ 的倍数（不包括自己）可以组成的所有子序列数 $\times$ 所有的 $x$ 可以组成的非空子序列个数**。

最后用总的非空子序列个数减去所有“不美丽”的子序列个数即为答案。

# 代码实现

```c++
void solve()
{
    int n;
    cin >> n;
    vector<int> as(n);
    cin >> as;

    vector<int> counts(n + 1);
    for (int a : as)
    {
        ++counts[a];
    }

    int64_t ans = (quickPow(2, n, mod) - 1 + mod) % mod;
    for (int g = 1; g <= n; ++g)
    {
        int count = 0;
        for (int flag = g * 2; flag <= n; flag += g)
        {
            count += counts[flag];
        }
        ans -= quickPow(2, count, mod) * ((quickPow(2, counts[g], mod) - 1 + mod) % mod) % mod;
        ans += mod; ans %= mod;
    }
    cout << ans << endl;
}
```

