# 题目链接

[P1004 [NOIP 2000 提高组] 方格取数 - 洛谷](https://www.luogu.com.cn/problem/P1004)

# 题目描述

设有 $n \times n$ 的方格图，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:

![](https://cdn.luogu.com.cn/upload/image_hosting/0bpummja.png)

某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。
此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。

## 输入格式

输入的第一行为一个整数 $n(1 \leq n \leq 9)$ 表示 $n \times n$ 的方格图。

接下来每行有三个整数 $x, y, a(1 \leq x \leq n, 1 \leq y \leq n, 1 \leq a \leq 10 ^ 9)$，表示位置 $(x, y)$ 的数为 $a$。

最后一行一个单独的 $0$ 表示输入结束。

## 输出格式

一个整数，表示 $2$ 条路径上取得的最大的和。保证结果在 int 范围内。

## 样例

| Input                                                        | OutPut |
| ------------------------------------------------------------ | ------ |
| 8<br/>2 3 13<br/>2 6  6<br/>3 5  7<br/>4 4 14<br/>5 2 21<br/>5 6  4<br/>6 3 15<br/>7 2 14<br/>0 0  0 | 67     |

# 解题思路

由于每个数只能被取一次，所以路径选取具有后效性，而选取的路径的后效性对当前路径的选取没有影响，而是在第二次路径选取时才会体现出来，后效性的滞后时间很久。因此要想办法缩短路径选取的滞后时间甚至消除后效性。

由于两次路径的起始点和约束条件相同，又因为路径选取不会对当前路径产生后效性，因此可以考虑同时走两条路来消除后效性，累加两条路上的数值，特殊地，当两条路走到同一位置时，该位置的数仅被取走一次。

用一个四维数组 $dp[x1][y1][x2][y2]$ 来表示第一条路走到位置 $(x1, y1)$，第二条路走到 $(x2, y2)$ 时最大能选取的数值和。由于是两条路径同时走，因此必须保证 $x1 + y1 = x2 + y2$，否则路径不合法。

由于每条路都有向右和向下两种方向可走，因此每个状态可由四个状态的最大值转移得来，因此前驱状态共有四种，分别为 $dp[x1 - 1][y1][x2 - 1][y2]$，$dp[x1 - 1][y1][x2][y2 - 1]$，$dp[x1][y1 - 1][x2 - 1][y2]$，$dp[x1][y1 - 1][x2][y2 - 1]$。

状态转移方程为：`dp[x1][y1][x2][y2] = max({dp[x1 - 1][y1][x2 - 1][y2], dp[x1 - 1][y1][x2][y2 - 1], dp[x1][y1 - 1][x2 - 1][y2], dp[x1][y1 - 1][x2][y2 - 1]}) + (x1 == x2 && y1 == x2 ? grid[x1][y1] : grid[x1][y1] + grid[x2][y2])`。

最终求出 $dp[n][n][n][n]$ 即为答案，表示两条路径最后同时走到终点时路径上数值和的最大值。

# 代码实现

```c++
void solve()
{
    int n;
    cin >> n;
    std::vector<std::vector<int>> grid(n + 1, std::vector<int>(n + 1));
    int x, y, a;
    while (cin >> x >> y >> a)
    {
        grid[x][y] = a;
    }

    std::vector<std::vector<std::vector<std::vector<int>>>> dp(n + 1,
                std::vector<std::vector<std::vector<int>>>    (n + 1,
                            std::vector<std::vector<int>>     (n + 1,
                                        std::vector<int>      (n + 1))));
    dp[1][1][1][1] = grid[1][1];
    for (int x1 = 1; x1 <= n; ++x1)
    {
        for (int y1 = 1; y1 <= n; ++y1)
        {
            for (int x2 = 1; x2 <= n; ++x2)
            {
                for (int y2 = 1; y2 <= n; ++y2)
                {
                    if (x1 + y1 != x2 + y2)
                        continue;
                    dp[x1][y1][x2][y2] = std::max({
                        dp[x1 - 1][y1][x2 - 1][y2],
                        dp[x1 - 1][y1][x2][y2 - 1],
                        dp[x1][y1 - 1][x2 - 1][y2],
                        dp[x1][y1 - 1][x2][y2 - 1]
                    }) + grid[x1][y1] + (x1 == x2 && y1 == y2 ? 0 : grid[x2][y2]);
                }
            }
        }
    }
    std::cout << dp[n][n][n][n] << std::endl;
}
```

