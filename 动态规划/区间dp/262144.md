# 题目链接

[P3147 [USACO16OPEN] 262144 P - 洛谷](https://www.luogu.com.cn/problem/P3147)

# 题目描述

贝西喜欢在手机上下载游戏来玩，尽管她确实觉得对于自己巨大的蹄子来说，小小的触摸屏用起来相当笨拙。

她对当前正在玩的这个游戏特别感兴趣。游戏开始时给定一个包含 $n$ 个正整数的序列，每个数的范围在 $1 \dots 40$ 之间。在一次操作中，贝西可以选择两个相邻且相等的数，将它们替换为一个比原数大 $1$ 的数（例如，她可以将两个相邻的 $7$ 替换为一个 $8$）。游戏的目标是最大化最终序列中的最大数值。请帮助贝西获得尽可能高的分数！

## 输入格式

第一行输入包含 $n(2 \leq n \leq 262144)$，接下来的 $n$ 行给出游戏开始时序列的 $n$ 个数字。

## 输出格式

一个整数表示贝西能生成的最大整数。

## 样例

| Input                     | OutPut |
| ------------------------- | ------ |
| 4<br/>1<br/>1<br/>1<br/>2 | 3      |

样例 1 说明：在示例中，贝西首先合并第二个和第三个 $1$，得到序列 $1\ 2\ 2$，然后将两个 $2$ 合并为 $3$。注意，合并前两个 $1$ 并不是最优策略。

# 解题思路

>   $262144 = 2 ^ {18}$

依题意，一个新数只能由两个相邻且相等的旧数转化得到，在极端情况下，所有数都相等的时候，最终会得到一个数，这个数等于初始的数加 $18$，因此最终的分数不会超过 $40 + 18 = 58$。

由于每次合并要求两个数相邻，因此对于每个合并得到的数，都可以表示为一个不间断的原始区间，而这个区间的位置又能由两个旧数的区间位置得到。一种比较好的记录方法是用二维数组 $dp[l][i]$ 表示以 $l$ 为左端点时，合并出数 $i$ 时区间的右端点。如果 $dp[l][i]$ 为不合法值，则表示以 $l$ 为左端点不能合并出数 $i$。

根据上述性质可知，合并得到 $dp[l][i]$ 的两个区间左端点分别为 $l$ 和 $r = dp[l][i - 1] + 1$，由此可以得到状态转移方程，`dp[l][i] = dp[l][i - 1] + dp[dp[l][i - 1] + 1][i - 1]`。

# 代码实现

```c++
void solve()
{
    int n;
    std::cin >> n;
    std::vector<int> as(n);
    std::cin >> as;
    ++as;

    constexpr int m = 40 + 18;

    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1));
    for (int i = 1; i <= n; ++i)
    {
        dp[i][as[i]] = i;
    }
    int ans = *std::max_element(as.begin(), as.end());
    for (int i = 2; i <= m; ++i)
    {
        for (int l = 1; l <= n; ++l)
        {
            if (!dp[l][i - 1])
                continue;
            int r = dp[l][i - 1] + 1;
            if (r > n)
                continue;
            if (!dp[r][i - 1])
                continue;
            dp[l][i] = dp[r][i - 1];
            ans = std::max(ans, i);
        }
    }
    std::cout << ans << std::endl;
}
```

