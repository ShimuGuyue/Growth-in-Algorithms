# 题目链接

[P2679 [NOIP 2015 提高组] 子串 - 洛谷](https://www.luogu.com.cn/problem/P2679)

# 题目描述

有两个仅包含小写英文字母的字符串 $A$ 和 $B$。

现在要从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，然后把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 $B$ 相等？

注意：子串取出的位置不同也认为是不同的方案。

## 输入格式

第一行是三个正整数 $n, m, k(1 \leq n \leq 1000, 1 \leq m \leq 200, 1 \leq k \leq m)$，分别表示字符串 $A$ 的长度，字符串 $B$ 的长度，以及问题描述中所提到的 $k$，每两个整数之间用一个空格隔开。

第二行包含一个长度为 $n$ 的字符串，表示字符串 $A$。

第三行包含一个长度为 $m$ 的字符串，表示字符串 $B$。

## 输出格式

一个整数，表示所求方案数。

由于答案可能很大，所以这里要求输出答案对 $1000000007$ 取模的结果。

## 样例

| Input                      | OutPut |
| -------------------------- | ------ |
| 6 3 1 <br/>aabaab <br/>aab | 2      |
| 6 3 2 <br/>aabaab <br/>aab | 7      |
| 6 3 3 <br/>aabaab <br/>aab | 7      |

样例说明：所有合法方案如下：（加下划线的部分表示取出的字串）

样例 1：$\underline{aab}\ aab$，$aab\ \underline{aab}$。
样例 2：$\underline{a}\ \underline{ab}aab$，$\underline{a}\ aba\ \underline{ab}$，$a\ \underline{a}\ ba\ \underline{ab}$，$aab\ \underline{a}\ \underline{ab}$，$\underline{aa}\ \underline{b}\ aab$，$\underline{aa}\ baa\ \underline{b}$，$aab\ \underline{aa}\ \underline{b}$。
样例 3：$\underline{a}\ \underline{a}\ \underline{b}\ aab$，$\underline{a}\ \underline{a}\ baa\ \underline{b}$，$\underline{a}\ ab\ \underline{a}\ a\ \underline{b}$，$\underline{a}\ aba\ \underline{a}\ \underline{b}$，$a\ \underline{a}\ b\ \underline{a}\ a\ \underline{b}$，$a\ \underline{a}\ ba\ \underline{a}\ \underline{b}$，$aab\ \underline{a}\ \underline{a}\ \underline{b}$。

# 解题思路

非常典型的计数类 dp，但需要综合使用时间优化和空间优化。

设置一个三维 dp 数组，其中 `dp[i][j][k]` 表示字符串 $A$ 的前 $i$ 个字符要匹配成字符串 $B$ 的前 $j$ 个字符，从 $A$ 中选取 $k$ 个非空子串的可行方案数。

然后对于每个状态转移，首先考虑是否使用 $A$ 的第 $i$ 个字符：

+   如果不使用该字符，则该情况的方案数和没有该字符时的方案数相同，即 `dp[i][j][k] += dp[i][j][k] + dp[i - 1][j][k]`。
+   然后考虑使用该字符，当且仅当 $A[i] = B[j]$，$A[i]$ 作为匹配串的末尾时可以使用。
    然后需要考虑该字符放在哪里，是单独作为一个新子串，还是添加到前一个子串的末尾：
    +   如果单独作为一个新子串，则该情况方案数等于 $A$ 的前 $i - 1$ 个字符匹配到 $B$ 的前 $j - 1$ 个字符，从 $A$ 中选取 $k - 1$ 个非空子串的方案数，即 `dp[i][j][k] += dp[i - 1][j - 1][k - 1]`。
    +   如果添加到前一个子串的末尾，则需要累加所有前边末尾串匹配的方案数。
        从小到大枚举前一个子串的长度 $x$，当 $A[i - x] \neq B[j - x]$ 时，前边一个子串的长度到达极限，枚举结束。
        对于每个长度的子串，累加其位置从 $A$ 中选取 $k - 1$ 个子串的方案数，即 `dp[i][j][k] += dp[i - x - 1][j - x - 1][k - 1]`。

到此为止，所有情况已经被枚举完成，但是时间复杂度和空间复杂度均超出限制，考虑优化。

首先考虑**时间优化**。

易观察到添加当前字符到前一个子串的末尾时，需要反复遍历前边的子串，消耗了大量时间，因此考虑从此处入手，使用一些标记手段省去遍历的过程，直接获取结果。

这里考虑使用前缀和来记录每种情况的前一个子串匹配方案数：

+   当 $A[i] = B[j]$ 时，$pres[i][j][k]$ 的值等于当前位置**新开一个子串的方案数**加上**在当前分段数下前一个子串的匹配方案数**，即 `pres[i][j][k] = dp[i - 1][j - 1][k - 1] + pres[i - 1][j - 1][k]`。
+   否则，该处不能向前匹配，将 $pres[i][j][k]$ 置为 $0$。

然后再考虑**空间优化**。

通过状态转移方程可以看出，推导 $dp[i][j][k]$ 的状态只会使用 $dp[i][...][...]$ 和 $dp[i - 1][...][...]$ 的状态，因此可以将 dp 数组的第一维使用滚动数组进行优化。**注意修改内层循环顺序。**

至此，所有优化已准备完毕，在技术过程中加入**取模**操作即可通过测试。

# 代码实现

```c++
void solve()
{
    int n, m, kk;
    cin >> n >> m >> kk;
    string s;
    string t;
    cin >> s;
    cin >> t;
    ++s;
    ++t;

    vector<vector<int>> dp0(m + 1, vector<int>(kk + 1));
    vector<vector<int>> dp1(m + 1, vector<int>(kk + 1));
    vector<vector<int>> pres0(m + 1, vector<int>(kk + 1));
    vector<vector<int>> pres1(m + 1, vector<int>(kk + 1));
    dp0[0][0] = dp1[0][0] = 1;
    for (int i = 1; i <= n; ++i)
    {
        for (int j = m; j >= 1; --j)
        {
            for (int k = kk; k >= 1; --k)
            {
                // 不选
                dp1[j][k] = dp0[j][k] % mod1;
                // 可选
                if (s[i] == t[j])
                {
                    // 新开子串 和 延续子串
                    pres1[j][k] = (dp0[j - 1][k - 1] + pres0[j - 1][k]) % mod1;
                    dp1[j][k] = (dp1[j][k] + pres1[j][k]) % mod1;
                }
                else
                {
                    pres1[j][k] = 0;
                }
            }
        }
        dp0 = dp1;
        pres0 = pres1;
    }
    cout << dp0[m][kk] << endl;
}
```

