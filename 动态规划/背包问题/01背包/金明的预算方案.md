# 题目描述

[P1064 [NOIP 2006 提高组] 金明的预算方案 - 洛谷](https://www.luogu.com.cn/problem/P1064)

![image-20251003161254376](%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88.assets/image-20251003161254376.png)

# 解题思路

有依赖的01背包问题。

由于附件只能在主件已经购买的情况下购买，而附属关系最多只有一层，并且一个逐渐最多有 $2$ 个附件，因此可以将一个主件及其所有附件看作一个整体。

进行动态规划的过程，如果当前加入的物品是一个**附件**，则跳过该物品，等待其主件加入时一起考虑；如果当前加入的物品是一个**主件**，则分别考虑**不要**、**只要主件**、**要主件和第一个附件**、**要主件和第二个附件**和**要主件和全部两个附件**五种情况分别讨论，取最大值。

由于只加入主件的时候才进行动态规划，因此需额外记录**上一个主件**的位置。

# 代码实现

```c++
void solve()
{
    int n, m;
    cin >> n >> m;

    vector<Item> items(m + 1);
    for (int i = 1; i <= m; ++i)
    {
        cin >> items[i].cost >> items[i].value >> items[i].parent;
        items[i].value *= items[i].cost;

        if (items[i].parent != 0)
            items[items[i].parent].childs += i;
    }

    int last = 0;
    vector<vector<int64_t>> dp(m + 1, vector<int64_t>(n + 1));
    for (int i = 1; i <= m; ++i)
    {
        if (items[i].parent != 0)
            continue;
        for (int j = 1; j <= n; ++j)
        {
            dp[i][j] = dp[last][j];
            int a, b, c;
            if (j - items[i].cost >= 0)
            {
                a = i;
                dp[i][j] = std::max(dp[i][j], dp[last][j - items[a].cost] + items[a].value);
            }
            if (items[i].childs.size() >= 1 && j - items[i].cost - items[items[i].childs[0]].cost >= 0)
            {
                a = i;
                b = items[i].childs[0];
                dp[i][j] = std::max(dp[i][j], dp[last][j - items[a].cost - items[b].cost] + items[a].value + items[b].value);
            }
            if (items[i].childs.size() >= 2 && j - items[i].cost - items[items[i].childs[1]].cost >= 0)
            {
                a = i;
                c = items[i].childs[1];
                dp[i][j] = std::max(dp[i][j], dp[last][j - items[a].cost - items[c].cost] + items[a].value + items[c].value);
            }
            if (items[i].childs.size() >= 2 && j - items[i].cost - items[items[i].childs[0]].cost - items[items[i].childs[1]].cost >= 0)
            {
                a = i;
                b = items[i].childs[0];
                c = items[i].childs[1];
                dp[i][j] = std::max(dp[i][j], dp[last][j - items[a].cost - items[b].cost - items[c].cost] + items[a].value + items[b].value + items[c].value);
            }
        }
        last = i;
    }
    int64_t ans = dp[last][n];
    cout << ans << endl;
}
```

